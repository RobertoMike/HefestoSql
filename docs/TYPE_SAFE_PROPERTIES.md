# Type-Safe Properties

Type-safe properties provide compile-time safety when referencing entity fields, eliminating typos and enabling IDE autocomplete.

## Overview

Instead of using error-prone string literals, you can use property references that are checked at compile time.

**Before (String-based):**
```java
.where("usrname", "John")  // Typo! Runtime error
```

**After (Type-safe):**
```java
.where(User_.username(), "John")  // Compile-time checked!
```

## Java: JPA Metamodel

For Java projects, use JPA Metamodel classes generated by the JPA annotation processor.

### Setup

Add the Hibernate JPA Metamodel Generator:

**Maven:**
```xml
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-jpamodelgen</artifactId>
    <version>6.2.0.Final</version>
    <scope>provided</scope>
</dependency>
```

**Gradle:**
```kotlin
dependencies {
    annotationProcessor("org.hibernate.orm:hibernate-jpamodelgen:6.2.0.Final")
}
```

### Generated Metamodel Classes

For each entity, a metamodel class is generated:

```java
// Entity
@Entity
public class User extends BaseModel {
    private String name;
    private String email;
    private Integer age;
    // ...
}

// Generated: User_.java
@StaticMetamodel(User.class)
public abstract class User_ {
    public static volatile SingularAttribute<User, String> name;
    public static volatile SingularAttribute<User, String> email;
    public static volatile SingularAttribute<User, Integer> age;
    // ...
}
```

### Usage Examples

#### WHERE Clauses

```java
import static io.github.robertomike.hefesto.enums.Operator.*;

// Simple where
List<User> users = Hefesto.make(User.class)
    .where(User_.name, "John")
    .get();

// With operator
List<User> adults = Hefesto.make(User.class)
    .where(User_.age, GREATER_OR_EQUAL, 18)
    .get();

// Multiple conditions
List<User> results = Hefesto.make(User.class)
    .where(User_.name, LIKE, "J%")
    .where(User_.age, GREATER, 25)
    .where(User_.email, NOT_NULL)
    .get();
```

#### Null Checks

```java
// IS NULL
List<User> usersWithoutPhoto = Hefesto.make(User.class)
    .whereIsNull(User_.photo)
    .get();

// IS NOT NULL
List<User> usersWithPhoto = Hefesto.make(User.class)
    .whereIsNotNull(User_.photo)
    .get();
```

#### IN / NOT IN Clauses

```java
// whereIn with varargs
List<User> users = Hefesto.make(User.class)
    .whereIn(User_.name, "John", "Jane", "Bob")
    .get();

// whereIn with collection
List<String> names = Arrays.asList("John", "Jane", "Bob");
List<User> users = Hefesto.make(User.class)
    .whereIn(User_.name, names)
    .get();

// whereNotIn
List<User> users = Hefesto.make(User.class)
    .whereNotIn(User_.status, "deleted", "banned")
    .get();
```

#### OR Conditions

```java
List<User> users = Hefesto.make(User.class)
    .where(User_.name, "John")
    .orWhere(User_.name, "Jane")
    .get();

// With operator
List<User> users = Hefesto.make(User.class)
    .where(User_.age, LESS, 18)
    .orWhere(User_.age, GREATER, 65)
    .get();
```

#### Joins

```java
// Type-safe join
List<User> users = Hefesto.make(User.class)
    .join(User_.posts)
    .get();

// Join with alias and type
List<User> users = Hefesto.make(User.class)
    .join(User_.posts, "userPosts", JoinOperator.LEFT)
    .get();
```

#### Ordering

```java
// Ascending order
List<User> users = Hefesto.make(User.class)
    .orderBy(User_.name)
    .get();

// Descending order
List<User> users = Hefesto.make(User.class)
    .orderBy(User_.age, Sort.DESC)
    .get();

// Multiple sort fields
List<User> users = Hefesto.make(User.class)
    .orderBy(User_.department)
    .orderBy(User_.name)
    .get();
```

#### SELECT and GROUP BY

```java
// Select specific fields
List<String> names = Hefesto.make(User.class)
    .addSelect(User_.name)
    .findFor(String.class);

// Group by with aggregate
List<Object[]> stats = Hefesto.make(User.class)
    .addSelect(User_.department)
    .count(User_.id, "userCount")
    .groupBy(User_.department)
    .findFor(Object[].class);
```

## Kotlin: Property References

For Kotlin projects, use Kotlin's native property references (`::property` syntax).

### Entity Setup

```kotlin
@Entity
@Table(name = "users")
class User : BaseModel() {
    
    @Column(name = "name")
    var name: String? = null
    
    @Column(name = "email")
    var email: String? = null
    
    @Column(name = "age")
    var age: Int? = null
    
    @OneToMany(mappedBy = "user")
    var posts: List<Post> = emptyList()
}
```

### Usage Examples

#### WHERE Clauses

```kotlin
import io.github.robertomike.hefesto.builders.Hefesto
import io.github.robertomike.hefesto.enums.Operator.*

// Simple where
val users = Hefesto.make(User::class.java)
    .where(User::name, "John")
    .get()

// With operator
val adults = Hefesto.make(User::class.java)
    .where(User::age, GREATER_OR_EQUAL, 18)
    .get()

// Multiple conditions
val results = Hefesto.make(User::class.java)
    .where(User::name, LIKE, "J%")
    .where(User::age, GREATER, 25)
    .get()
```

#### Null Checks

```kotlin
// IS NULL
val usersWithoutPhoto = Hefesto.make(User::class.java)
    .whereIsNull(User::photo)
    .get()

// IS NOT NULL
val usersWithPhoto = Hefesto.make(User::class.java)
    .whereIsNotNull(User::photo)
    .get()
```

#### IN / NOT IN Clauses

```kotlin
// whereIn with varargs
val users = Hefesto.make(User::class.java)
    .whereIn(User::name, "John", "Jane", "Bob")
    .get()

// whereIn with collection
val names = listOf("John", "Jane", "Bob")
val users = Hefesto.make(User::class.java)
    .whereIn(User::name, names)
    .get()

// whereNotIn
val users = Hefesto.make(User::class.java)
    .whereNotIn(User::status, "deleted", "banned")
    .get()
```

#### Ordering

```kotlin
import io.github.robertomike.hefesto.enums.Sort

// Ascending order
val users = Hefesto.make(User::class.java)
    .orderBy(User::name)
    .get()

// Descending order
val users = Hefesto.make(User::class.java)
    .orderBy(User::age, Sort.DESC)
    .get()
```

## Benefits

### 1. Compile-Time Safety

```java
// Typo caught at compile time
.where(User_.usrname, "John")  // Error: cannot find symbol usrname
```

### 2. Refactoring Support

When you rename a field in your entity:

```java
// Before
private String email;

// After rename to contactEmail
private String contactEmail;
```

All metamodel references are automatically updated by your IDE, and any string literals will cause compilation errors.

### 3. IDE Autocomplete

As you type `User_.`, your IDE shows all available fields with their types.

### 4. Type Checking

```java
// Type mismatch caught at compile time
.where(User_.age, "not a number")  // Error: incompatible types
```

## Mixing String and Type-Safe References

You can mix both approaches in the same query:

```java
List<User> users = Hefesto.make(User.class)
    .where(User_.name, "John")        // Type-safe
    .where("department.name", "IT")   // String-based for deep navigation
    .join("posts", join -> {
        join.where(Post_.status, "published");  // Type-safe
    })
    .get();
```

**When to use strings:**
- Deep property navigation (`"department.location.city"`)
- Dynamic field names from user input
- Fields that don't have metamodel generation

**When to use type-safe references:**
- Direct entity properties
- Join relationships
- When refactoring safety is important

## Testing

Type-safe properties are particularly valuable in tests:

```java
@Test
void shouldFindUsersByAge() {
    List<User> adults = Hefesto.make(User.class)
        .where(User_.age, GREATER_OR_EQUAL, 18)
        .get();
    
    assertThat(adults)
        .isNotEmpty()
        .allMatch(user -> user.getAge() >= 18);
}
```

If the `age` field is renamed, this test will fail at compile time rather than at runtime.

## Common Patterns

### Complex Queries

```java
List<User> users = Hefesto.make(User.class)
    .whereAny(group -> {
        group.where(User_.age, LESS, 18);
        group.where(User_.age, GREATER, 65);
    })
    .whereAll(group -> {
        group.whereIsNotNull(User_.email);
        group.where(User_.status, "active");
    })
    .orderBy(User_.name)
    .get();
```

### With Joins

```java
List<User> users = Hefesto.make(User.class)
    .join(User_.posts, join -> {
        join.where(Post_.status, "published");
        join.where(Post_.views, GREATER, 100);
    })
    .where(User_.verified, true)
    .orderBy(User_.createdAt, Sort.DESC)
    .get();
```

### Aggregations

```java
Long count = Hefesto.make(User.class)
    .where(User_.age, GREATER, 18)
    .where(User_.status, "active")
    .countResults();

Double avgAge = Hefesto.make(User.class)
    .where(User_.department, "Engineering")
    .avg("age")  // String for aggregate function
    .findFirstFor(Double.class);
```

## Best Practices

1. **Use type-safe references for direct properties** - Maximizes compile-time safety
2. **Use strings for deep navigation** - `"department.location.city"` is clearer than multiple joins
3. **Generate metamodel classes in CI** - Ensures they're always up to date
4. **Don't commit generated files** - Add `*_.java` to `.gitignore` for metamodel classes
5. **Keep entity and metamodel in sync** - Use annotation processor during development

## Troubleshooting

### Metamodel Classes Not Generated

**Problem**: `User_` class not found

**Solution**:
1. Ensure annotation processor is configured
2. Rebuild project: `./gradlew clean build`
3. Check IDE annotation processing is enabled

### Wrong Field Type

**Problem**: Type mismatch when using metamodel

**Solution**: The metamodel is generated from entity annotations. Check:
1. Entity field type matches usage
2. Metamodel class is up to date (rebuild if needed)

### Can't Use Deep Navigation

**Problem**: Want to reference `user.department.name` with type-safety

**Solution**: Type-safe references only work for direct entity properties. Use strings for deep navigation:
```java
.where("department.name", "IT")
```

Or create explicit joins:
```java
.join(User_.department)
.where(Department_.name, "IT")
```
